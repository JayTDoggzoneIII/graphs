INF = 10**9
def FB(edges:list,n:int,m:int,start:int) -> list:
    f = [INF]*n
    f[start] = 0
    for k in range(n-1):
        for i in range(m):
            u = edges[i][0]
            v = edges[i][1]
            w = edges[i][2]
            if (f[u]<INF):
                if f[u]+w<f[v]:
                    f[v] = f[u]+w
    return f;
'''
-edges - массив ребер.
 n - количество вершин.
 m - количество ребер.
 start - вершина для которой запускается алгоритм.
-Граф хранить в виде списка ребер.
 Элемент в массиве edges вида (i,j,w) означает, что можно попасть из i в j за цену w.
-Функция FB возвращает массив с кратчайшими длинами от start до каждой, 
 причем если пути нету то на месте длины пути будет константа INF.
-Нумерация с 0.
(Алгоритм Форда - Беллмана)
'''